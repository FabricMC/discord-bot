plugins {
	id("java")
	id("java-library")
	id("application")
	id("com.github.johnrengelman.shadow") version "8.1.1"
	id("com.diffplug.spotless") version "6.25.0"
}

group "net.fabricmc"
version "1.0-SNAPSHOT"

repositories {
	mavenCentral()
}

allprojects {
	apply plugin: "java"
	apply plugin: "java-library"
	apply plugin: "com.diffplug.spotless"

	repositories {
		mavenCentral()

		maven {
			name = "Sonatype Snapshots"
			url = "https://oss.sonatype.org/content/repositories/snapshots"
		}

		maven {
			name = "Fabric"
			url = "https://maven.fabricmc.net"
		}
	}

	// Common dependencies
	dependencies {
		compileOnly("org.jetbrains:annotations:20.1.0")

		// tag parser artifact does not need a full db
		if (project != rootProject.project(":tag-parser")) {
			// Database
			implementation("com.zaxxer:HikariCP:3.4.5")
			implementation("org.xerial:sqlite-jdbc:3.36.0.3")
		}

		// Logging
		implementation("org.apache.logging.log4j:log4j-core:2.17.2")
		implementation("org.apache.logging.log4j:log4j-slf4j-impl:2.17.2")

		// Json Serialization
		implementation("com.google.code.gson:gson:2.8.6")

		implementation("it.unimi.dsi:fastutil-core:8.5.4");

		// TODO: Do we want this so we can :irritater: instead of raw id for custom emotes?
		//  https://github.com/vdurmont/emoji-java
	}

	spotless {
		java {
			licenseHeaderFile(rootProject.file("HEADER")).yearSeparator(", ")
		}

		// Spotless tries to be smart by ignoring package-info files, however license headers are allowed there
		// TODO: Replicate on module-info if needed?
		//  FIXME: Currently broken
//        format("package-info.java") {
//            target "**/package-info.java"
//
//            // Only update license headers when changes have occurred
//            ratchetFrom("origin/master")
//            // Regex is `/**` or `package`
//            licenseHeaderFile(rootProject.file("HEADER"), "/\\*\\*|package").yearSeparator(", ")
//        }
	}

	java {
		modularity.inferModulePath = true
	}

	tasks.withType(JavaCompile).configureEach {
		options.release = 16
	}
}

// Main bot module
application {
	mainClass = "net.fabricmc.discord.bot.Main"
	executableDir = "run"
}

configurations {
	javacord {
		extendsFrom implementation
	}
	jda {
		extendsFrom implementation
	}
}

// Setup dependencies for big boi jar
dependencies {
	subprojects.each {
		if (!it.path.startsWith(":ioimpl")) {
			implementation(it)
		}
	}

	javacord project(":ioimpl:javacord")
	jda project(":ioimpl:jda")
}

jar {
	enabled = false
}
shadowJar {
	enabled = false
}

def createImplementationJar(String name, Configuration configuration) {
	return tasks.register("${name}Jar", com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
		configurations = [configuration]
		archiveClassifier = name
		from(sourceSets.main.output)

		manifest {
			attributes 'Main-Class': 'net.fabricmc.discord.bot.Main'
		}

		exclude("META-INF/*.SF", "META-INF/*.DSA", "META-INF/*.RSA")
	}
}

def javacordJar = createImplementationJar("javacord", project.configurations.javacord)
def jdaJar = createImplementationJar("jda", project.configurations.jda)

tasks.named("assemble") {
	dependsOn(javacordJar)
	dependsOn(jdaJar)
}


// Propagate core dependency to subprojects
subprojects {
	if (project != project(":core")) {
		dependencies {
			implementation(rootProject.project(":core"))
		}
	}
}

java {
	modularity.inferModulePath = true
}
